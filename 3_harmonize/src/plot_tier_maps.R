# A function that creates hex maps of record counts for each tier of a selected
# parameter's harmonized dataset

plot_tier_maps <- function(dataset, parameter, map_crs = 9311,
                           custom_width = 6.5, custom_height = 8){
  
  # Read in pre-filtered dataset of map locations for the dataset
  sf_list <- read_rds("3_harmonize/in/us_territories_list.rds")
  
  # Confirm the CRS is what the user wants
  sf_list <- map(
    .x = sf_list,
    .f = ~ if(st_crs(.x) != map_crs){
      st_transform(x = .x, crs = map_crs)
    }
  )
  
  # Datum varies throughout the dataset; build a conversion table.
  epsg_codes <- tribble(
    ~datum, ~epsg,
    # American Samoa Datum
    "AMSMA", 4169,
    # Midway Astro 1961
    "ASTRO", 37224,
    # Guam 1963
    "GUAM", 4675,
    # High Accuracy Reference Network for NAD83
    "HARN", 4957,
    # Johnston Island 1961 (Spelled Johnson in WQX)
    "JHNSN", 6725,
    # North American Datum 1927
    "NAD27", 4267,
    # North American Datum 1983
    "NAD83", 4269,
    # Old Hawaiian Datum
    "OLDHI", 4135,
    # Assume WGS84
    "OTHER", 4326,
    # Puerto Rico Datum
    "PR", 4139,
    # St. George Island Datum
    "SGEOR", 4138,
    # St. Lawrence Island Datum
    "SLAWR", 4136,
    # St. Paul Island Datum
    "SPAUL", 4137,
    # Assume WGS84
    "UNKWN", 4326,
    # Wake-Eniwetok 1960
    "WAKE", 37229,
    # World Geodetic System 1972
    "WGS72", 4322,
    # World Geodetic System 1984
    "WGS84", 4326
  )
  
  # Create a simplified sf object from the provided dataset
  recs_sf <- dataset %>%
    select(tier, MonitoringLocationIdentifier, lat, lon, datum) %>%
    left_join(
      x = .,
      y = epsg_codes,
      by = "datum"
    ) %>%
    # Group by CRS 
    split(f = .$epsg) %>%
    # Transform and re-stack
    map_df(.x = .,
           .f = ~ .x %>%
             st_as_sf(coords = c("lon", "lat"),
                      crs = unique(.x$epsg)) %>%
             st_make_valid() %>%
             st_transform(crs = map_crs)) %>%
    # More informative facet panel labels
    mutate(tier_label = case_when(
      tier == 0 ~ "Tier 0: Restrictive",
      tier == 1 ~ "Tier 1: Narrowed",
      tier == 2 ~ "Tier 2: Inclusive",
      tier == 3 ~ "Tier 3: Inclusive"
    ))
  
  # Iteratively create each map
  walk2(.x = sf_list,
        .y = names(sf_list),
        .f = ~{
          
          # Make the map
          map_plot <- sf_to_df(recs_sf, fill = TRUE) %>%
            ggplot() +
            geom_hex(aes(x = x, y = y),
                     bins = 75) +
            geom_sf(data = .x,
                    color = "black",
                    fill = NA) +
            scale_fill_viridis_c("Record count",
                                 trans = "log",
                                 breaks = breaks_log(n = 6),
                                 labels = label_number(big.mark = ",")) +
            xlab(NULL) +
            ylab(NULL) +
            coord_sf(xlim = c(min(st_coordinates(.x)[,"X"]),
                              max(st_coordinates(.x)[,"X"])),
                     ylim = c(min(st_coordinates(.x)[,"Y"]),
                              max(st_coordinates(.x)[,"Y"]))) +
            facet_wrap(vars(tier_label), ncol = 1) +
            guides(x = guide_axis(check.overlap = TRUE),
                   y = guide_axis(check.overlap = TRUE)) +
            theme_bw()
          
          # Export with autogenerated filename
          ggsave(filename = paste0("3_harmonize/out/",
                                   parameter, "_",
                                   .y, "_",
                                   "tier_hex_map.png"),
                 plot = map_plot, units = "in", device = "png",
                 width = custom_width, height = custom_height)
        })
}
