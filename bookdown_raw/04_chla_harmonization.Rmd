---
output:
  github_document:
    html_preview: false
params:
  documented_drops: NA
  chla_chars: NA
always_allow_html: true
---

# Chlorophyll harmonization process

```{r echo=FALSE} 
documented_drops <- params$documented_drops
chla_chars <- params$chla_chars
```

```{r echo = FALSE}
step_order_rev <- max(documented_drops$order):min(documented_drops$order)

step_data <- documented_drops %>%
  group_by(step) %>%
  mutate(scaled = scale(n_rows, center = FALSE)) %>%
  ungroup() %>%
  mutate(order = factor(order,
                        levels = step_order_rev),
         rows_label = paste0(short_reason,
                             ":  ",
                             round((n_rows / 1000000), 1),
                             " M rows")) %>%
  filter(step == "chla harmonization") 
```


### Initial dataset

```{r echo=FALSE}
step_0_rows <- filter(step_data,
                      order == 0) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")
```

After the pre-harmonization process the chlorophyll-only WQP dataset contains `r step_0_rows` rows. This dataset contains the following user-defined `characteristicNames`: `r chla_chars`.

These names are chosen in order to select for only those measurements that pertain to chlorophyll a.

```{r echo = FALSE}
step_data %>%
  filter(order == 0) %>%
  ggplot() +
  geom_bar(aes(x = order, y = scaled, fill = order),
           stat = "identity")  +
  geom_text_repel(aes(x = order, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = 10, direction = -1)[1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>


### Filter for water media

```{r echo = FALSE}
step_1_rows <- filter(step_data,
                      order == 1) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_1_dropped <- filter(step_data,
                         order == 1) %>%
  pull(number_dropped) %>%
  round(digits = 2)
```

The first step in chla harmonization is to ensure that the media type for the data is `"water"` or `"Water"`. This should just be a precautionary step: `r step_1_dropped` rows are removed. The final row count after this is `r step_1_rows`.

```{r echo = FALSE}
step_data %>%
  filter(order %in% 0:1) %>%
  ggplot() +
  geom_bar(aes(x = order, y = scaled, fill = order),
           stat = "identity")  +
  geom_text_repel(aes(x = order, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = 10, direction = -1)[2:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Document and remove fails

```{r echo = FALSE}
step_2_rows <- filter(step_data,
                      order == 2) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_2_dropped <- filter(step_data,
                         order == 2) %>%
  mutate(thou_dropped = number_dropped / 1000) %>%
  pull(thou_dropped) %>%
  round(digits = 2) %>%
  paste0(., " thousand")
```

In this step we filter out records based on indications that they have failed data quality assurance or quality control for some reason given by the data provider (these instances are referred to here as "failures"). 

After reviewing the contents of the `ActivityCommentText`, `ResultLaboratoryCommentText`, `ResultCommentText`, and `ResultMeasureValue_original`columns, we developed a list of terms that captured the majority of instances where records had failures or unacceptable measurements. We found the phrasing to be consistent across columns and so we search for the same (case agnostic) terms in all four locations. The terms are: "beyond accept", "cancelled", "contaminat", "error", "fail", "improper", "instrument down", "interference", "invalid", "no result", "no test", "not accept", "outside of accept", "problem", "QC EXCEEDED", "questionable", "suspect", "unable", "violation", "reject", "no data".

Below are pie charts that break down the number of failure detections by column. Note that the plotting below is automated and so if one or more of the columns listed above are not plotted, this indicates that the column(s) did not return any matches for the failure phrases. Also note that the detection of one of the potential failure phrases is not mutually exclusive from other phrases showing up in the same record within the same column or one of the other three columns.

<br>

#### ActivityCommentText fail detects

<img src="3_harmonize/out/chla_ActivityCommentText_fail_pie.png" alt="ActivityCommentText failure detects" width="650"/>

#### ResultCommentText fail detects
<img src="3_harmonize/out/chla_ResultCommentText_fail_pie.png" alt="ResultCommentText failure detects" width="650"/>

#### ResultLaboratoryCommentText fail detects
<img src="3_harmonize/out/chla_ResultLaboratoryCommentText_fail_pie.png" alt="ResultLaboratoryCommentText failure detects" width="650"/>

<br>

<!-- <img src="3_harmonize/out/chla_ResultCommentText_fail_pie.png" alt="ResultCommentText failure detects" width="650"/> -->

<!-- <br> -->

`r step_2_dropped` rows are removed after detecting failure-related phrases and `r step_2_rows` rows remain.

```{r echo = FALSE}
step_data %>%
  filter(order %in% 0:2) %>%
  ggplot() +
  geom_bar(aes(x = order, y = scaled, fill = order),
           stat = "identity")  +
  geom_text_repel(aes(x = order, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = 10, direction = -1)[3:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Clean MDLs

```{r echo = FALSE}
step_3_rows <- filter(step_data,
                      order == 3) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_3_dropped <- filter(step_data,
                         order == 3) %>%
  pull(number_dropped) %>%
  round(digits = 2)
```

In this step method detection limits (MDLs) are used to clean up the reported values. When a numeric value is missing for the data record (i.e., `NA` or text that became `NA` during an `as.numeric` call) we check for non-detect language in the `ResultLaboratoryCommentText`, `ResultCommentText`, `ResultDetectionConditionText`, and `ResultMeasureValue` columns. This language can be `"non-detect"`, `"not detect"`, `"non detect"`, `"undetect"`, or  `"below"`.

If non-detect language exists then we use the `DetectionQuantitationLimitMeasure.MeasureValue` column for the MDL, otherwise if there is a `<` and a number in the `ResultMeasureValue` column we use that number instead.

We then use a random number between 0 and `0.5 * MDL` as the record's value moving forward.

This should not result in a change in rows but we still check: `r step_3_dropped` rows are removed. The final row count after this is `r step_3_rows`.

```{r echo = FALSE}
step_data %>%
  filter(order %in% 0:3) %>%
  ggplot() +
  geom_bar(aes(x = order, y = scaled, fill = order),
           stat = "identity")  +
  geom_text_repel(aes(x = order, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = 10, direction = -1)[4:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>


### Clean approximate values

```{r echo = FALSE}
step_4_rows <- filter(step_data,
                      order == 4) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_4_dropped <- filter(step_data,
                         order == 4) %>%
  pull(number_dropped) %>%
  round(digits = 2)
```

Step 4 involves a similar process as for MDL cleaning. We flag "approximated" values in the dataset. The `ResultMeasureValue` column gets checked for **all** three of the following conditions:
  
  1. Numeric-only version of the column is still `NA` after MDL cleaning
  2. The original column text contained a number
  3. Any of `ResultLaboratoryCommentText`, `ResultCommentText`, or `ResultDetectionConditionText` match this regular expression, ignoring case: `"result approx|RESULT IS APPROX|value approx"`
  
We then use the approximate value as the record's value moving forward.

This should not result in a change in rows but we still check: `r step_4_dropped` rows are removed. The final row count after this is `r step_4_rows`.

```{r echo = FALSE}
step_data %>%
  filter(order %in% 0:4) %>%
  ggplot() +
  geom_bar(aes(x = order, y = scaled, fill = order),
           stat = "identity")  +
  geom_text_repel(aes(x = order, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = 10, direction = -1)[5:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Clean values with "greater than" data

```{r echo = FALSE}
step_5_rows <- filter(step_data,
                      order == 5) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_5_dropped <- filter(step_data,
                         order == 5) %>%
  pull(number_dropped) %>%
  round(digits = 2)
```

Step 5 is similar to the MDL and approximate value cleaning processes, and follows the approximate cleaning process most closely. The goal is to clean up values that were entered as "greater than" some value. The `ResultMeasureValue` column gets checked for **all** three of the following conditions:
  
  1. Numeric-only version of the column is still `NA` after MDL & approximate cleaning
  2. The original column text contained a number
  3. The original column text contained a `>`
  
We then use the "greater than" value (without `>`) as the record's value moving forward.

This should not result in a change in rows but we still check: `r step_5_dropped` rows are removed. The final row count after this is `r step_5_rows`.

```{r echo = FALSE}
step_data %>%
  filter(order %in% 0:5) %>%
  ggplot() +
  geom_bar(aes(x = order, y = scaled, fill = order),
           stat = "identity")  +
  geom_text_repel(aes(x = order, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = 10, direction = -1)[6:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>


### Harmonize record units

```{r echo = FALSE}
step_6_rows <- filter(step_data,
                      order == 6) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_6_dropped <- filter(step_data,
                         order == 6) %>%
  mutate(thou_dropped = number_dropped / 1000) %>%
  pull(thou_dropped) %>%
  round(digits = 2) %>%
  paste0(., " thousand")
```

The next step in chla harmonization is converting the units of WQP records. These can vary widely. We create the following conversion table, which is used to translate units provided in WQP into micrograms/L:

```{r echo=FALSE, message = FALSE}
read_csv("../3_harmonize/out/chla_unit_table.csv") %>%
  kable() %>%
  kable_paper() %>%
  kable_styling(full_width = FALSE)
```


`r step_6_dropped` rows are removed. The final row count after this is `r step_6_rows`.


```{r echo = FALSE}
step_data %>%
  filter(order %in% 0:6) %>%
  ggplot() +
  geom_bar(aes(x = order, y = scaled, fill = order),
           stat = "identity")  +
  geom_text_repel(aes(x = order, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = 10, direction = -1)[7:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>


### Clean depth data

```{r echo = FALSE}
step_7_rows <- filter(step_data,
                      order == 7) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_7_dropped <- filter(step_data,
                         order == 7) %>%
  mutate(thou_dropped = number_dropped / 1000) %>%
  pull(thou_dropped) %>%
  round(digits = 2) %>%
  paste0(., " thousand")
```

The next harmonization step cleans the four depth-related columns obtained from the WQP. The details behind this step are covered in the *Depth flags* section of the *Tiering, flagging, and quality control philosophy* chapter.

Through our depth filtering we lose `r step_7_dropped` rows and have `r step_7_rows` remaining.

```{r echo = FALSE}
step_data %>%
  filter(order %in% 0:7) %>%
  ggplot() +
  geom_bar(aes(x = order, y = scaled, fill = order),
           stat = "identity")  +
  geom_text_repel(aes(x = order, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = 10, direction = -1)[8:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Filter and tier analytical methods

```{r echo = FALSE}
step_8_rows <- filter(step_data,
                      order == 8) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_8_dropped <- filter(step_data,
                         order == 8) %>%
  mutate(thou_dropped = number_dropped / 1000) %>%
  pull(thou_dropped) %>%
  round(digits = 2) %>%
  paste0(., " thousand")
```

We next review the analytical methods used in measuring chlorophyll a, primarily by classifying the text provided with each record in `ResultAnalyticalMethod.MethodName`. Once these methods are classified we arrange them into hierarchical tiers as described in the *Analytical method tiering* section of the *Tiering, flagging, and quality control philosophy* chapter.

However, prior to classification we check the `ResultAnalyticalMethod.MethodName` column for names that indicate non-chlorophyll measurements. We remove these because it's impossible to interpret contradictory information provided within the same data record. Phrases used to flag and remove unrelated methods from chlorophyll a data are: "sulfate", "sediment", "5310", "counting", "plasma", "turbidity", "coliform", "carbon", "2540", "conductance", "nitrate", "nitrite", "nitrogen", "alkalin", "zooplankton", "phosphorus", "periphyton", "peri", "biomass", "temperature", "elemental analyzer", "2320".

This process drops `r step_8_dropped` rows leaving `r step_8_rows` remaining.

The next step towards creating analytical tiers is to then classify the methods in `ResultAnalyticalMethod.MethodName` into either: HPLC methods, spectrophotometer and fluorometer methods, or methods for which a pheophytin correction is recorded as part of the methodology. These classifications are not the final tiers, but they inform the tiering in the final step of this process. The criteria for each of the above classifications are:

+ **HPLC:** Detection of "447", "chromatography", or "hplc" in the `ResultAnalyticalMethod.MethodName` or presence of 70951 or 70953 in the `USGSPCode` column
+ **Spectro/fluoro:** Detection of "445", "fluor", "Welshmeyer", "fld", "10200", "446", "trichromatic", "spectrophoto", "monochrom", "monchrom", or "spec" not as part of a word in `ResultAnalyticalMethod.MethodName`
+ **Pheophytin correction:** Detection of "correct", "445", "446", or "in presence" in `ResultAnalyticalMethod.MethodName` or detection of "corrected for pheophytin" or "free of pheophytin" in `CharacteristicName`

Finally, we group the data into three tiers as described in *Tiering, flagging, and quality control philosophy*. As a reminder, these tiers are:

+ **Tier 0: Restrictive.** Data that are verifiably self-similar across organizations and time-periods and can be considered highly reliable and interoperable
+ **Tier 1: Narrowed.** Data that we have good reason to believe are self-similar, but for which we can’t verify full interoperability across data providers
+ **Tier 2: Inclusive.** Data that are assumed to be reliable and are harmonized to our best ability given the information available from the data provider. This tier includes `NA` or non-resolvable descriptions for the analytical method, which often make up the majority of methods descriptions for any given parameter.

For chlorophyll a, the following rules are used:

+ **Tier 0**: Includes records using HPLC methods
+ **Tier 1**: Spectrophotometer and fluorometer methods that **are also** pheophytin-corrected ***OR*** records where `USGSPCode` is 32209
+ **Tier 2**: All other records by default, including `NA` methods and in-situ probes

At this point we export a file (`3_harmonize/out/chla_analytical_tiering_record.csv`) that contains a record of how specific method text was tiered and how many row counts corresponded to each method.

<br>

```{r echo = FALSE}
step_data %>%
  filter(order %in% 0:8) %>%
  ggplot() +
  geom_bar(aes(x = order, y = scaled, fill = order),
           stat = "identity")  +
  geom_text_repel(aes(x = order, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = 10, direction = -1)[9:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Flag based on field methods

```{r echo = FALSE}
step_9_rows <- filter(step_data,
                       order == 10) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_9_dropped <- filter(step_data,
                         order == 10) %>%
  pull(number_dropped) %>%
  round(digits = 2)
```

The final step in our chla harmonization is flagging field sampling methods based primarily on the `SampleCollectionMethod.MethodName` column. We first classify each record into either in vitro or in situ methods (i.e., in vitro assumes a water sample was collected and take to a lab for analysis; in situ assumes a measurement was taken in place). 

We used the following strings to mark **in vitro** samples: "grab", "bottle", "vessel", "bucket", "jar", "composite", "integrate", "UHL001", "surface", "filter", "filtrat", "1060B", "kemmerer", "collect", "rosette", "equal width", "vertical", "van dorn", "bail", "sample", "sampling", "lab" not in the middle of another word, or a "G" on its own as shorthand for "grab". **In situ** samples were detected using "in situ", "probe", or "ctd".

Lastly we created the field flag based on whether the sampling method used agrees with the analytical method. Flags of 0 indicated that the field sampling method is in agreement with the analytical method, 1 indicates that the field sampling methods are uncharacteristic of the analytical method, and anything with analytical tier of 2 is given a field flag of 2 because of the range of potential analytical methods and corresponding sampling methods possible for the inclusive analytical tier.

The following rules are used for chlorophyll a field sampling flags:

+ **Flag 0**: Restrictive and narrowed analytical tiers with in vitro field methods
+ **Flag 1**: Restrictive and narrowed analytical tiers with in situ field methods
+ **Flag 2**: Anything in the inclusive tier


No records should be removed by this process and so there are `r step_9_dropped` rows dropped leaving `r step_9_rows` remaining in the final harmonized chla dataset.

```{r echo = FALSE}
step_data %>%
  filter(order %in% 0:10) %>%
  ggplot() +
  geom_bar(aes(x = order, y = scaled, fill = order),
           stat = "identity")  +
  geom_text_repel(aes(x = order, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = 10, direction = -1)[10:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Harmonized chlorophyll a

At this point the harmonization of the chlorophyll a WQP data is complete and we export the final dataset for use later in the workflow.

