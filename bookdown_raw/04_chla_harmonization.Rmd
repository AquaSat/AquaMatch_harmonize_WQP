---
output:
  github_document:
    html_preview: false
params:
  documented_drops: NA
  chla_chars: NA
always_allow_html: true
---

<!-- Image settings -->

```{r setup-chunk, include=FALSE}
knitr::opts_chunk$set(dev = "png",
                      dpi = 300)
```


# Chlorophyll *a* (chla) harmonization process

```{r echo=FALSE} 
documented_drops <- params$documented_drops %>%
  filter(grepl(pattern = "chla|chlorophyll", x = step, ignore.case = TRUE),
         !((step == "chla harmonization") & short_reason == "Start"))
chla_chars <- params$chla_chars
```

Following the completion of the {dataRetrieval} download process described previously, the pipeline contains raw WQP data for each parameter of interest. Before we harmonize each parameter we run through a series of universal "pre-harmonization" steps, which ensure that the datasets are appropriately formatted when entering their harmonization routines.

The text below first walks through the pre-harmonization steps for the raw chlorophyll *a* dataset and then delves into the specifics of the harmonization process.


```{r echo = FALSE}
# Redo the ordering of the steps, conceptualizing the pre-harmonization and
# harmonization processes as one step
documented_drops <- bind_rows(
  # Make sure pre-harmonization comes first
  documented_drops %>%
    filter(grepl(pattern = "pre-harmonization", x = step, ignore.case = TRUE)) %>%
    arrange(order),
  documented_drops %>%
    filter(!grepl(pattern = "pre-harmonization", x = step, ignore.case = TRUE)) %>%
    arrange(order)) %>%
  # New order is just row nums
  mutate(reorder = row_number())

step_order_rev <- max(documented_drops$reorder):min(documented_drops$reorder)

max_steps <- max(documented_drops$reorder)

step_data <- documented_drops %>%
  mutate(scaled = scale(n_rows, center = FALSE),
         reorder = factor(reorder,
                          levels = step_order_rev),
         rows_label = paste0(short_reason,
                             ":  ",
                             round((n_rows / 1000000), 1),
                             " M rows"))
```

## Pre-harmonization of the raw chlorophyll WQP dataset

```{r echo=FALSE}
step_counter <- 1

step_1_rows <- filter(step_data,
                      reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")
```

At the start of the pre-harmonization process the raw chlorophyll WQP dataset contains `r step_1_rows` rows.

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps,
                                     direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Missing results

```{r echo = FALSE}
step_counter <- 2

step_2_rows <- filter(step_data,
                      reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_2_dropped <- filter(step_data,
                         reorder == step_counter) %>%
  mutate(thou_row = number_dropped / 1000) %>%
  pull(thou_row) %>%
  round(digits = 2) %>%
  paste0(., " thousand")
```

Next, records that have missing data are dropped from the dataset. Several criteria are used when checking for missing data. If any of the below criteria are met the row is flagged as missing:

1. Both the result column and detection limit column had `NA` data
2. Result, result unit, activity comment, laboratory comment, and result comment columns are all `NA`
3. The result comment column contains any user-provided text indicating a missing value, currently including: `analysis lost`, `not analyzed`, `not recorded`, `not collected`, or `no measurement taken`

`r step_2_dropped` rows are dropped, resulting in a final count of `r step_2_rows`.

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>


### Filter status

```{r echo = FALSE}
step_counter <- 3

step_3_rows <- filter(step_data,
                      reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_3_dropped <- filter(step_data,
                         reorder == step_counter) %>%
  mutate(thou_row = number_dropped / 1000) %>%
  pull(thou_row) %>%
  round(digits = 2) %>%
  paste0(., " thousand")
```

The final step in pre-harmonization is to filter the `ResultStatusIdentifier` column to include only the following statuses:

+ `"Accepted"` 
+ `"Final"`
+ `"Historical"`
+ `"Validated"`
+ `"Preliminary"`
+ `NA`

These statuses generally indicate a reliable result having been reached, however we also include `NA` in an effort to be conservative. More specifically, when making decisions for this and other columns we occasionally retain `NA` values if removing the records would otherwise drop 10% or more of the available data.

This step removes `r step_3_dropped` rows of data, leaving it with `r step_3_rows` rows remaining.

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

## Harmonization-ready chlorophyll dataset


Once ready for harmonization, the chlorophyll *a*-only WQP dataset contains the following user-defined `characteristicNames`: `r chla_chars`.

These names are chosen in order to select for only those measurements that pertain to chlorophyll *a*.

<br>

### Filter for water media

```{r echo = FALSE}
step_counter <- 4

step_4_rows <- filter(step_data,
                      reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_4_dropped <- filter(step_data,
                         reorder == step_counter) %>%
  pull(number_dropped) %>%
  round(digits = 2)
```

We next ensure that the media type for all chlorophyll data is `"Surface Water"`, `"Water"`, `"Estuary"`, or `NA`. `r step_4_dropped` rows are removed. The final row count after this is `r step_4_rows`.

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Document and remove fails

```{r echo = FALSE}
step_counter <- 5

step_5_rows <- filter(step_data,
                      reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_5_dropped <- filter(step_data,
                         reorder == step_counter) %>%
  mutate(thou_dropped = number_dropped / 1000) %>%
  pull(thou_dropped) %>%
  round(digits = 2) %>%
  paste0(., " thousand")
```

In this step we filter out records based on indications that they have failed data quality assurance or quality control for some reason given by the data provider (these instances are referred to here as "failures"). 

After reviewing the contents of the `ActivityCommentText`, `ResultLaboratoryCommentText`, `ResultCommentText`, and `ResultMeasureValue_original` columns, we developed a list of terms that captured the majority of instances where records had failures or unacceptable measurements. We found the phrasing to be consistent across columns and so we searched for the same (case agnostic) terms in all four locations. The terms are: "beyond accept", "cancelled", "contaminat", "error", "fail", "improper", "instrument down", "interference", "invalid", "no result", "no test", "not accept", "outside of accept", "problem", "QC EXCEEDED", "questionable", "suspect", "unable", "violation", "reject", "no data".

Below are pie charts that break down the number of failure detections by column. Note that the plotting below is automated so if one or more of the columns listed above are not plotted, this indicates that the column(s) did not return any matches for the failure phrases. Also note that a single record can contain multiple failure phrases; therefore, failure phrases are not mutually exclusive.

<br>

#### ActivityCommentText fail detects

<img src="3_harmonize/out/chla_ActivityCommentText_fail_pie.png" alt="ActivityCommentText failure detects" width="650"/>

#### ResultCommentText fail detects
<img src="3_harmonize/out/chla_ResultCommentText_fail_pie.png" alt="ResultCommentText failure detects" width="650"/>

#### ResultLaboratoryCommentText fail detects
<img src="3_harmonize/out/chla_ResultLaboratoryCommentText_fail_pie.png" alt="ResultLaboratoryCommentText failure detects" width="650"/>

<br>

<!-- <img src="3_harmonize/out/chla_ResultCommentText_fail_pie.png" alt="ResultCommentText failure detects" width="650"/> -->

<!-- <br> -->

`r step_5_dropped` rows are removed after detecting failure-related phrases and `r step_5_rows` rows remain.

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Clean MDLs

```{r echo = FALSE}
step_counter <- 6

step_6_rows <- filter(step_data,
                      reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_6_dropped <- filter(step_data,
                         reorder == step_counter) %>%
  pull(number_dropped) %>%
  round(digits = 2)
```

In this step method detection limits (MDLs) are used to clean up the reported values. When a numeric value is missing for the data record (i.e., `NA` or text that became `NA` during an `as.numeric` call) we check for non-detect language in the `ResultLaboratoryCommentText`, `ResultCommentText`, `ResultDetectionConditionText`, and `ResultMeasureValue` columns. This language can be `"non-detect"`, `"not detect"`, `"non detect"`, `"undetect"`, or  `"below"`.

If non-detect language exists then we use the `DetectionQuantitationLimitMeasure.MeasureValue` column for the MDL, otherwise if there is a `<` and a number in the `ResultMeasureValue` column we use that number instead.

We then use a random number between 0 and `0.5 * MDL` as the record's value moving forward. Once the process is complete we filter out any negative values in the dataset. 

We produce a new column, `mdl_flag`, from the MDL cleaning process. Records where no MDL-based adjustment was made and which are at or above the MDL are assigned a 0. Records with corrected values based on the MDL method are assigned a 1. Finally, records where no MDL-based adjustment was made and which contain a numeric value below the provided MDL are assigned a 2.

Most of this step should not result in a change in rows, but we do drop records with negative measurement values. This results in `r step_6_dropped` rows being removed. The final row count after this is `r step_6_rows`.

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>


### Clean approximate values

```{r echo = FALSE}
step_counter <- 7

step_7_rows <- filter(step_data,
                      reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_7_dropped <- filter(step_data,
                         reorder == step_counter) %>%
  pull(number_dropped) %>%
  round(digits = 2)
```

Cleaning approximate values involves a similar process as for MDL cleaning. We flag "approximated" values in the dataset. The `ResultMeasureValue` column gets checked for **all** three of the following conditions:

1. Numeric-only version of the column is still `NA` after MDL cleaning
2. The original column text contained a number
3. Any of `ResultLaboratoryCommentText`, `ResultCommentText`, or `ResultDetectionConditionText` match this regular expression, ignoring case: `"result approx|RESULT IS APPROX|value approx"`

We then use the approximate value as the record's value moving forward.

Records with corrected values based on the above method are noted with a 1 in the `approx_flag` column.

This should not result in a change in rows but we still check: `r step_7_dropped` rows are removed. The final row count after this is `r step_7_rows`.

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Clean values with "greater than" data

```{r echo = FALSE}
step_counter <- 8

step_8_rows <- filter(step_data,
                      reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_8_dropped <- filter(step_data,
                         reorder == step_counter) %>%
  pull(number_dropped) %>%
  round(digits = 2)
```

The next step is similar to the MDL and approximate value cleaning processes, and follows the approximate cleaning process most closely. The goal is to clean up values that were entered as "greater than" some value. The `ResultMeasureValue` column gets checked for **all** three of the following conditions:

1. Numeric-only version of the column is still `NA` after MDL & approximate cleaning
2. The original column text contained a number
3. The original column text contained a `>`

We then use the "greater than" value (without `>`) as the record's value moving forward.

Records with corrected values based on the above method are noted with a 1 in the `greater_flag` column.

This should not result in a change in rows but we still check: `r step_8_dropped` rows are removed. The final row count after this is `r step_8_rows`.

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Drop unresolved NA measurements

```{r echo = FALSE}
step_counter <- 9

step_9_rows <- filter(step_data,
                      reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_9_dropped <- filter(step_data,
                         reorder == step_counter) %>%
  # mutate(thou_dropped = number_dropped / 1000) %>%
  pull(number_dropped) %>%
  round(digits = 2) #%>%
# paste0(., " thousand")
```

The goal of the preceding three steps was to prevent records with seemingly missing measurement data from being dropped if there was still a chance of recovering a usable value. At this point we've finished with that process and we proceed to check for remaining records with `NA` values in their `harmonized_value` column. If they exist, they are dropped.

`r step_9_dropped` rows are removed. The final row count after this is `r step_9_rows`.


```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Harmonize record units

```{r echo = FALSE}
step_counter <- 10

step_10_rows <- filter(step_data,
                       reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_10_dropped <- filter(step_data,
                          reorder == step_counter) %>%
  mutate(thou_dropped = number_dropped / 1000) %>%
  pull(thou_dropped) %>%
  round(digits = 2) %>%
  paste0(., " thousand")
```

The next step in chla harmonization is converting the units of WQP records. We create the following conversion table, which is used to translate units provided in WQP into micrograms per liter (ug/L):

```{r echo=FALSE, message = FALSE}
read_csv("../3_harmonize/out/chla_unit_table.csv") %>%
  kable() %>%
  kable_paper() %>%
  kable_styling(full_width = FALSE)
```

<br>

Below is a pie chart that breaks down the different unit codes that were dropped in the unit harmonization process, and how many records were lost with each code.

<br>

<img src="3_harmonize/out/chla_unit_drop_pie.png" alt="ResultMeasure.MeasureUnitCode mismatched codes" width="650"/>

<br>

Additionally we provide a set of histograms of harmonized measurements by `CharacteristicName`:

<br>

<img src="3_harmonize/out/chla_charname_dists.png" alt="Distribution of chl *a* values by CharacteristicName" width="650"/>

<br>

`r step_10_dropped` rows are removed. The final row count after this is `r step_10_rows`.


```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>


### Clean depth data

```{r echo = FALSE}
step_counter <- 11

step_11_rows <- filter(step_data,
                       reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_11_dropped <- filter(step_data,
                          reorder == step_counter) %>%
  pull(number_dropped) %>%
  round(digits = 2)
```

The next harmonization step cleans the four depth-related columns obtained from the WQP. The details behind this step are covered in the *Depth flags* section of the *Tiering, flagging, and quality control philosophy* chapter.

This should not result in a change in rows but we still check: `r step_11_dropped` rows are removed. The final row count after this is `r step_11_rows`.

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Filter and tier methods

```{r echo = FALSE}
step_counter <- 12

step_12_rows <- filter(step_data,
                       reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_12_dropped <- filter(step_data,
                          reorder == step_counter) %>%
  mutate(thou_dropped = number_dropped / 1000) %>%
  pull(thou_dropped) %>%
  round(digits = 2) %>%
  paste0(., " thousand")
```

We next review the analytical methods used in measuring chlorophyll *a*, primarily by classifying the text provided with each record in `ResultAnalyticalMethod.MethodName`. Once these methods are classified we arrange them into hierarchical tiers as described in the *Method tiering* section of the *Tiering, flagging, and quality control philosophy* chapter.

However, prior to classification we check the `ResultAnalyticalMethod.MethodName` column for names that indicate non-chlorophyll *a* measurements. Phrases used to flag and remove unrelated methods from chlorophyll *a* data are: "sulfate", "sediment", "5310", "counting", "plasma", "turbidity", "coliform", "carbon", "2540", "conductance", "nitrate", "nitrite", "nitrogen", "alkalin", "zooplankton", "phosphorus", "periphyton", "peri", "biomass", "temperature", "elemental analyzer", "2320".

This process drops `r step_12_dropped` rows leaving `r step_12_rows` remaining.

The next step towards creating tiers is to then classify the methods in `ResultAnalyticalMethod.MethodName` into either: HPLC methods, spectrophotometer and fluorometer methods, or methods for which a pheophytin correction is recorded as part of the methodology. These classifications are not the final tiers, but they inform the tiering in the final step of this process. The criteria for each of the above classifications are:

+ **HPLC:** Detection of "447", "chromatography", or "hplc" in the `ResultAnalyticalMethod.MethodName` or presence of 70951 or 70953 in the `USGSPCode` column
+ **Spectro/fluoro:** Detection of "445", "fluor", "Welshmeyer", "fld", "10200", "446", "trichromatic", "spectrophoto", "monochrom", "monchrom", or "spec" not as part of a word in `ResultAnalyticalMethod.MethodName`
+ **Pheophytin correction:** Detection of "correct", "445", "446", or "in presence" in `ResultAnalyticalMethod.MethodName` or detection of "corrected for pheophytin" or "free of pheophytin" in `CharacteristicName`


Finally, we group the data into three tiers as described in *Tiering, flagging, and quality control philosophy*. These tiers are:

<br>

<!-- Table created with https://www.tablesgenerator.com/markdown_tables -->

| Tier | Name        | Description                                                                                                                                                                                                                                                                                            | Chl *a* details                                                                                                              |   |
|------|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------|---|
| 0    | Restrictive | Data that are verifiably self-similar across organizations and time-periods and can be considered highly reliable and interoperable                                                                                                                                                                    | Includes records using HPLC methods                                                                                          |   |
| 1    | Narrowed    | Data that we have good reason to believe are self-similar, but for which we can’t verify full interoperability across data providers                                                                                                                                                                   | Spectrophotometer and fluorometer methods that **are also** pheophytin-corrected ***OR*** records where `USGSPCode` is 32209 |   |
| 2    | Inclusive   | Data that are assumed to be reliable and are harmonized to our best ability given the information available from the data provider. This tier includes `NA` or non-resolvable descriptions for the analytical method, which often make up the majority of methods descriptions for any given parameter | All other records by default, including `NA` methods and *in situ* probes                                                    |   |

<br>

**Note**: Spectrophotometer and fluorometer methods that are labeled as pheophytin-corrected are grouped into the "Narrowed" tier. Depending on the exact implementation of EPA method 445, the correction philosophy may vary, and there is no agreed upon method to rectify inconsistencies in data entry related to these methodological differences. The final harmonization product that aggregates simultaneous records does *not* retain the `CharacteristicName` or `ResultAnalyticalMethod.MethodName` columns. However, the non-aggregated version of the harmonized dataset (`p3_chla_preagg_grouped`) includes those columns. We encourage any users that want to explicitly compare or account for pheophytin correction to use the `p3_chla_preagg_grouped` dataset. 

<br>

At this point we export a file (`3_harmonize/out/chla_tiering_record.csv`) that contains a record of how specific method text was tiered and how many row counts corresponded to each method.

<br>

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Flag based on field methods

```{r echo = FALSE}
step_counter <- 13

step_13_rows <- filter(step_data,
                       reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_13_dropped <- filter(step_data,
                          reorder == step_counter) %>%
  pull(number_dropped) %>%
  round(digits = 2)
```

Next we flag field sampling methods based primarily on the `SampleCollectionMethod.MethodName` column. We first classify each record into either *in vitro* or *in situ* methods (i.e., *in vitro* assumes a water sample was collected and taken to a lab for analysis; *in situ* assumes a measurement was obtained in the field). 

We used the following strings to mark **in vitro** samples: "grab", "bottle", "vessel", "bucket", "jar", "composite", "integrate", "UHL001", "surface", "filter", "filtrat", "1060B", "kemmerer", "collect", "rosette", "equal width", "vertical", "van dorn", "bail", "sample", "sampling", "lab" not in the middle of another word, or a "G" on its own as shorthand for "grab". **In situ** samples were detected using "*in situ*", "probe", or "ctd".

Lastly we created the field flag based on whether the sampling method used agrees with the analytical method. Flags of 0 indicated that the field sampling method is in agreement with the analytical method, 1 indicates that the field sampling methods are uncharacteristic of the analytical method, and anything with tier of 2 is given a field flag of 2 due to the ambiguity associated with those observations' analytical methods and corresponding sampling methods. 

The following rules are used for chlorophyll a field sampling flags:

+ **Flag 0**: Restrictive and narrowed tiers with in vitro field methods
+ **Flag 1**: Restrictive and narrowed tiers with in situ field methods
+ **Flag 2**: Any entry in the inclusive tier


No records should be removed by this process and so there are `r step_13_dropped` rows dropped leaving `r step_13_rows` remaining in the harmonized chlorophyll *a* dataset.

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Miscellaneous flag

```{r echo = FALSE}
step_counter <- 14

step_14_rows <- filter(step_data,
                       reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_14_dropped <- filter(step_data,
                          reorder == step_counter) %>%
  pull(number_dropped) %>%
  round(digits = 2)
```

Next we add a placeholder for the miscellaneous flag column, `misc_flag`.

Some parameters will have additional flagging requirements that chlorophyll *a* does not, so we include this placeholder to maintain the same columns across all parameter data products.

No records should be removed by this process and so there are `r step_14_dropped` rows dropped leaving `r step_14_rows` remaining in the harmonized chlorophyll *a* dataset.

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Remove unrealistic values

```{r echo = FALSE}
step_counter <- 15

step_15_rows <- filter(step_data,
                       reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_15_dropped <- filter(step_data,
                          reorder == step_counter) %>%
  pull(number_dropped) %>%
  round(digits = 2)
```

Before finalizing the dataset we remove chlorophyll *a* values that are beyond a realistic threshold. We use 1000 ug/L as our cutoff for removal (Wetzel, 2001, Chapter 15, Figure 19).

`r step_15_dropped` rows are removed. The final row count after this is `r step_15_rows`.

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Aggregate simultaneous records

```{r echo = FALSE}
step_counter <- 16

step_16_rows <- filter(step_data,
                       reorder == step_counter) %>%
  mutate(mil_row = n_rows / 1000000) %>%
  pull(mil_row) %>%
  round(digits = 2) %>%
  paste0(., " million")

step_16_dropped <- filter(step_data,
                          reorder == step_counter) %>%
  mutate(mil_dropped = number_dropped / 1000000) %>%
  pull(mil_dropped) %>%
  round(digits = 2) %>%
  paste0(., " million")
```

The final step of chlorophyll *a* harmonization is to aggregate simultaneous observations. Any group of samples determined to be simultaneous are simplified into a single record containing the median and standard deviation of the group. These can be either true duplicate records or records with non-identical values recorded at the same time and place and by the same organization.

We identify simultaneous records to aggregate by creating identical subgroups (`subgroup_id`) from the following columns: `parameter`, `OrganizationIdentifier`, `MonitoringLocationIdentifier`, `ActivityStartDateTime`, `harmonized_top_depth_value`, `harmonized_top_depth_unit`, `harmonized_bottom_depth_value`, `harmonized_bottom_depth_unit`, `harmonized_discrete_depth_value`, `harmonized_discrete_depth_unit`, `depth_flag`, `mdl_flag`, `approx_flag`, `greater_flag`, `tier`, `field_flag`, `harmonized_units`. This selection limits the columns included in the final dataset, but we also provide a copy of the AquaMatch dataset prior to its aggregation (pipeline target `p3_chla_preagg_grouped`), and including the `subgroup_id` column, so that users can use the disaggregated data as well and match make joins between dataset versions.

The final, aggregated values are presented in the `harmonized_value` and `harmonized_value_sd` columns. The number of rows used per group is recorded in the `harmonized_row_count` column.

`r step_14_dropped` rows dropped leaving `r step_14_rows` remaining in the final harmonized and aggregated chlorophyll *a* dataset.

```{r echo = FALSE}
step_data %>%
  filter(reorder %in% 1:step_counter) %>%
  ggplot() +
  geom_bar(aes(x = reorder, y = scaled, fill = reorder),
           stat = "identity")  +
  geom_text_repel(aes(x = reorder, y = 0.1, label = rows_label),
                  bg.color = "white", bg.r = 0.15,
                  point.size = NA,
                  xlim = c(-Inf, Inf),
                  ylim =  c(-Inf, Inf),
                  nudge_x = 0.1,
                  hjust = "left") +
  xlab("Step number") +
  ylab(NULL) +
  scale_fill_manual(values = viridis(n = max_steps, direction = -1)[step_counter:1]) +
  scale_x_discrete(drop = F) +
  coord_flip() +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none")
```

<br>

### Harmonized chlorophyll a

At this point the harmonization of the chlorophyll *a* data from the WQP is complete and we export the final dataset for use later in the workflow.

Below is a final set of histograms showing the distribution of harmonized measurements broken down by `tier` ***after*** aggregating simultaneous records.

<br>

<img src="3_harmonize/out/chla_tier_dists_postagg.png" alt="Distribution of chl *a* values by tier" width="650"/>

<br>
